$title=Evolution de Java
-----
<p>J'ai déjà parlé du projet euler <a href="librairie-mathematiques.html">ici</a>. Dans ce billet, nous allons voir comment résoudre le premier problème en utilisant des technologies de plus en plus récentes, ce qui permet d'apprécier l'évolution des langages basés sur la JVM. Tout d'abord, voici l'énoncé : </p>
<blockquote>Si on liste tous les entiers naturels inférieurs à 10 qui sont multiples de 3 ou de 5, on obtient 3, 5, 6 et 9. La somme de ces nombres est 23. Trouvez la somme de tous les multiples de 3 ou de 5 inférieurs à 1000</blockquote>

<h2>Avec Java 6</h2>
<pre class="prettyprint">
public class Java6Euler1 {
    public static void main(String[] args) {
        int sum = 0;
        for (int i = 1; i &lt; 1000; i++) {
            if (i % 3 == 0 || i % 5 == 0) {
                sum += i;
            }
        }
        System.out.println(sum);
    }
}
</pre>
<p>Ce code semble familier, clair et relativement lisible. Alors pourquoi chercher à l'améliorer ? Le premier problème est que l'itération est côté client et deuxièment, cet algorithme n'est pas parallélisable, et donc n'est pas optimisé les processeurs multi-coeur qui sont devenus la norme aujourd'hui.</p>
<h2>Avec Guava</h2>
<p><a href="http://code.google.com/p/guava-libraries/">Guava</a> est une librairie développée par Google qui offre notamment une API Collection riche et un support partiel de la programmation fonctionnelle. Cette librairie remplace avantageusement la librairie commons collections d'Apache, tombé en désuetude. 
<pre class="prettyprint">
import java.util.Collection;

import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.common.collect.ContiguousSet;
import com.google.common.collect.DiscreteDomains;
import com.google.common.collect.Ranges;

public class GuavaEuler1 {
    public static void main(String[] args) {
        ContiguousSet&lt;Integer&gt; range = Ranges.closedOpen(1, 1000).asSet(
                DiscreteDomains.integers());

        Collection&lt;Integer&gt; filtered = Collections2.filter(range,
                new Predicate&lt;Integer&gt;() {
                    @Override
                    public boolean apply(Integer i) {
                        return (i % 3 == 0 || i % 5 == 0);
                    }
                });

        int sum = 0;
        for (Integer i : filtered) {
            sum += i;
        }
        System.out.println(sum);
    }
}
</pre>
<p>On progresse : l'iteration et le filtrage sont pris en charge par la librairie et l'execution n'est pas intrinsèquement en série. Malheureusement, la syntaxe n'est pas pratique car très verbeuse ...</p>

<h2>Avec Scala</h2>
<p><a href="http://www.scala-lang.org/">Scala</a> est un nouveau langage sur la JVM qui combine la programmation orientée objet et la programmation fonctionnelle. Scala supporte nativement les lambda expressions (i.e. les fonctions anonymes) et les fonctions d'ordre supérieur (i.e. une fonction prenant en paramètre d'entrée une ou plusieurs fonctions et/ou renvoyant une fonction). Le code suivant montre la puissance du langage.</p>
<pre class="prettyprint">
object euler1 extends App {
  println((1 until 1000).filter(n =&gt; n % 3 == 0 || n % 5 == 0).sum)
}
</pre>
<p>C'est clairement l'objectif à atteindre au niveau de la syntaxe. Le langage a été conçu dés le départ dans ce but.</p>

<h2>Avec Java 8</h2>
<p><a href="http://openjdk.java.net/projects/jdk8/">Java 8</a> apportera le support très attendu des <a href="http://openjdk.java.net/projects/lambda/">lambda-expressions</a> (JSR 335). Une version <a href="http://jdk8.java.net/lambda/">binary snapshot</a> permet d'essayer ces nouveautés.</p>
<pre class="prettyprint">
import java.util.ArrayList;
import java.util.List;

public class Java8Euler1 {
    public static void main(String[] args) {
        List&lt;Integer&gt; range = new ArrayList&lt;Integer&gt;();
        for (int i=0; i&lt;1000; i++) {
            range.add(i);
        }
		
        System.out.println(range.filter(s -&gt; s % 3 == 0 || s % 5 == 0).
                reduce(0, (x,y) -&gt; x + y));
    }
}
</pre>
<p>Ce code utilise deux nouveautés de Java 8 : les lambda expressions et les méthodes d'extension virtuelles. La syntaxe retenue pour les lambda est celle du C#. Le code est lisible et assez proche de Scala. Voici quelques précisions techniques :</p>
<ul>
    <li>Les méthodes d'extension virtuelles permettent d'adresser le problème de l'evolution des API existantes, et notamment l'API Collection. Elles permettent d'ajouter une implémentation par défaut sur les interfaces. L'interface <code>Iterable</code> gagne ainsi une méthode <code>filter</code> qui prend en paramètre un <code>Predicate</code> et possède une implémentation par défaut.</li>
</ul>
<pre class="prettyprint">
Iterable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) default {
    return Iterables.filter(this, predicate);
}
</pre>
<ul>
    <li>Le type de la lambda expression est déduit en fonction du contexte par le compilateur. On parle alors de <i>target typing</i>. Dans le code ci-dessus, l'expression <code>s -&gt; s % 3 == 0 || s % 5 == 0</code> est de type <code>Predicate</code>. Le type est toujours une interface à une seule méthode.</li>
    <li>Le type des paramètres est déduit à partir de la signature de la méthode de l'interface cible. Dans notre cas, le compilateur déduit que les paramètres <code>s</code>, <code>x</code> et <code>y</code> sont des <code>Integer</code>. C'est une extension de l'inférence de type apparue avec les génériques de Java 5 et étendue avec l'opérateur diamant de Java 7.
</ul>
<p>Le code est beaucoup plus lisible qu'avec Guava, ce qui démontre la nécessité de mettre à jour le langage car les librairies tierces ne permettent pas d'obtenir le même résultat. De plus, la méthode <code>reduce</code> est supportée alors que Guava ne la supporte pas.
<p>Référence : Les slides de Brian Goetz à Devoxx : <a href="http://blogs.oracle.com/briangoetz/resource/devoxx-lang-lib-vm-co-evol.pdf">devoxx-lang-lib-vm-co-evol.pdf</a></p>
