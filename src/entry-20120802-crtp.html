$title=CRTP en Java
$description=
-----
<p>Ce billet porte sur le CRTP, Curiously Recuring Template Pattern. Mais que se cache derri√®re ce terme √©trange. Rassurez-vous, aucun d√©veloppeur n'a √©t√© bless√© pour r√©aliser ce billet. Nous allons voir comment le besoin √©merge. Nous souhaitons instancier un objet immuable Parent, ce que permet le pattern Builder. 
nous utilisons un Builder : cela arrive lors de la mise en place d'un builder. Pour des raisons de simplicit√©, nous n'allons mettre que le code n√©cessaire √† la compr√©henssion:

<pre>
public class Child1Builder {
    private String parentProperty;
    private String child1Property;

    public Child1Builder setParentProperty(String parentProperty) {
        this.parentProperty = parentProperty;
        return this;
    }
    
    public Child1Builder setChild1Property(String child1Property) {
        this.child1Property = child1Property;
        return this;
    }


    public static void main(String[] args) {
        Child1Builder childBuilder = new Child1Builder();
        childBuilder.setParentProperty("parent").setChild1Property("childProperty");
    }
}


public class Child2Builder {
    private String parentProperty;
    private String child2Property;

    public Child2Builder setParentProperty(String parentProperty) {
        this.parentProperty = parentProperty;
        return this;
    }
    
    public Child2Builder setChild2Property(String child2Property) {
        this.child2Property = child2Property;
        return this;
    }


    public static void main(String[] args) {
        Child2Builder childBuilder = new Child2Builder();
        childBuilder.setParentProperty("parent").setChild2Property("childProperty");
    }
}

</pre>
Nous utilisons 2 sous-classe pour faire apparaitre la duplication de code
Nous pouvons aussi vouloir instancier des objets d'une sous classe, Child. On peut alors vouloir cr√©er des objets d'une sous classe
<pre>
public class ParentBuilder {
    public String parentProperty;

    public ParentBuilder setParentProperty(String parentProperty) {
        this.parentProperty = parentProperty;
        return this;
    }
}

public class Child1Builder extends ParentBuilder {
    private String child1Property;

    public Child1Builder setChild1Property(String child1Property) {
        this.child1Property = child1Property;
        return this;
    }


    public static void main(String[] args) {
        Child1Builder childBuilder = new Child1Builder();
        childBuilder.setParentProperty("parent").setChild1Property("childProperty");
    }
}

</pre>
Ne comile pas. La superclasse a besoin de renvoyer le type de la sousclasse -> g√©n√©rique

Cette impl√©mentation fonctionne mais l'oeil averti aura detect√© la duplication de code au niveau de la m√©thode setParentProperty. Nous allons donc tenter de supprimer la m√©thode. Malheureusement, le code ne compile plus car
Il reste √† refactorer pour supprimer le code dupliqu√© de la m√©thode setParentProperty.
Le probl√®me est que l'appel √† setParentProperty renvoie une sinstance de Builder, il n'est pas possible d'appeler la m√©thode setChildProperty. Il va donc falloir parametrer le retour de la m√©thode setXxxProperty.
La m√©thode setParentProperty doit donc renvoyer une instance de ChildBuilder

Inside TaxPayer, we want to use the derived class P directly in the extortCash() method. However, the only way of getting an instance without compiler warnings is to pass it in from the subclass. We can solve this issue with a factory method called getDetailedType() that returns the subclass. 

Dans ParentBuilder, nous voulons utiliser la classe d√©riv√©e T in the setParentProperty method. Cependant, le seul moyen d'obtenir une instance sans warning du compilateur est de le passer √† partir de la sous classe. Nous pouvons r√©soudre ce probl√®me avec une factory m√©thode getThis() qui retourne la sous classe.

<pre>

public abstract class ParentBuilder<T> {
    public String parentProperty;

    public T setParentProperty(String parentProperty) {
        this.parentProperty = parentProperty;
        return getThis();
    }
    
    public abstract T getThis();
}

public class Child1Builder extends ParentBuilder<Child1Builder> {
    private String child1Property;

    public Child1Builder setChild1Property(String child1Property) {
        this.child1Property = child1Property;
        return this;
    }

    public static void main(String[] args) {
        Child1Builder childBuilder = new Child1Builder();
        childBuilder.setParentProperty("parent").setChild1Property("childProperty");
    }

    @Override
    public Child1Builder getThis() {
        return this;
    }
}
<p>Il faut donc changer le ParentBuilder pour ajouter le parametre generique T, qui doit √™tre une sous classe de ParentBuilder. Cela donne donc l'expression class ParentBuilder<T extends ParentBuilder<T>> qui peut paraitre √©trange et montre la complexit√© des g√©n√©riques qui se cache derri√®re leur apparente simplicit√©. Derni√®re am√©lioration, le build du builder est de construire une API fluent, le retour du setXxxProperty doit √™tre un builder. On va donc utiliser un bounded generic pour faire cela :<code>public abstract class ParentBuilder<T extends ParentBuilder<T>> {</code> et on voit apparaitre la r√©cursion.
 
source : http://www.javaspecialists.co.za/archive/newsletter.do?issue=123 Strategy Pattern with Generics
http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html#What%20is%20the%20getThis%20trick? What is the "getThis" trick?

