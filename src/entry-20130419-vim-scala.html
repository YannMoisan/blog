$title=Vim comme IDE Scala
$description=Vim comme IDE Scala
-----
<p>
Je suis en cours de conversion de IntelliJ Idea vers Vim, pour développer en Scala. J'ai déjà brièvement parlé de Vim et Scala <a href="tdd-en-scala.html">dans ce billet</a>.
Le but de ce billet est de présenter comment configurer Vim pour avoir les principales fonctionnalités d'un IDE.
L'utilisation de Vim en entreprise me semble assez marginale en France, comme s'en étonne Bodil Stokke dans ce tweet :
</p>
<blockquote>« Enterprise guys give me such a feeling of disconnect: they're arguing IDEA vs Eclipse instead of vim vs emacs. »</blockquote>
<p>Il me paraît donc important de mentionner que moult développeurs talentueux utilisent Vim.
En voici quelques-uns qui sont pour moi une source d'inspiration :
</p>

<ul>
    <li><a href="https://twitter.com/derekwyatt">Derek Wyatt</a>, auteur de Akka Concurrency ;</li>
    <li><a href="https://twitter.com/spf13">Steve Francia</a>, évangeliste 10gen ;</li>
    <li><a href="https://twitter.com/paulrouget">Paul Rouget</a>, développeur Mozilla ;</li>
    <li><a href="https://twitter.com/ornicar">Thibault Duplessis</a>, développeur Scala.</li>
</ul>

<h2>Coloration syntaxique</h2>
<p>
Il suffit d'installer le plugin <a href="https://github.com/derekwyatt/vim-scala">vim-scala</a>. Ce plugin gère aussi l'indentation et la détection des fichiers scala.
</p>

<h2>Navigation dans le code source</h2>
<p>
Ctags est un outil classique du monde Unix. Il ne supporte pas Scala par défaut, mais il est très simple d'ajouter ce support en créant/modifiant un fichier <code>~/.ctags</code>. Vous pouvez récuperer le fichier <a href="http://latestbuild.net/scala-ctags-and-vim-tagbar">ici</a>. On peut maintenant sauter à la définition du terme sous le curseur en tapant <code>&lt;C-]&gt;</code>.</p>
<p>Alors que l'IDE recompile de manière transparente le code pour permettre la complétion, il faut lancer ctags à la main. Le mapping suivant permet d'effectuer cela en tapant <code>F5</code>.
<pre class="prettyprint">
map &lt;F5&gt; :!ctags -R
</pre>
<p>Le plugin <a href="https://github.com/majutsushi/tagbar/">tagbar</a> donne un aperçu de la structure du code source du fichier courant, comme la vue <i>structure</i> d'IntelliJ Idea. 
Le langage Scala n'est pas supporté par défaut. Il faut ajouter la ligne suivante dans le <code>.vimrc</code>
<pre class="prettyprint">
let g:tagbar_type_scala = {
    \ 'ctagstype' : 'Scala',
    \ 'kinds'     : [
        \ 'p:packages:1',
        \ 'V:values',
        \ 'v:variables',
        \ 'T:types',
        \ 't:traits',
        \ 'o:objects',
        \ 'a:aclasses',
        \ 'c:classes',
        \ 'r:cclasses',
        \ 'm:methods'
    \ ]
\ }</pre>
<p>
J'ai noté deux limites : tagbar confond méthode et variable, et les méthodes ne sont pas regroupées par objet.
</p>

<h2>Complétion</h2> 
<p>
La complétion de code est native dans Vim. Les commandes sont <code>&lt;C-n&gt;</code> pour la complétion classique et <code>&lt;C-x&gt;&lt;C-]&gt;</code> pour la complétion basée sur les tags
</p>

<h2>Rechercher dans le projet</h2>
<p>
ack est un meilleur grep. Le plugin <a href="https://github.com/mileszs/ack.vim">Ack.vim</a> ajoute une commande <code>:Ack [options] {pattern} [{directory}]</code> qui permet de chercher récursivement <i>pattern</i> dans <i>directory</i>. Les résultats alimentent le quick fix de Vim. Les mappings suivant permettent de faciliter la navigation dans les occurences du quick fix.
<pre class="prettyprint">
nnoremap &lt;silent&gt; [q :cprevious&lt;CR&gt;
nnoremap &lt;silent&gt; ]q :cnext&lt;CR&gt;
nnoremap &lt;silent&gt; [Q :cfirst&lt;CR&gt;
nnoremap &lt;silent&gt; ]Q :clast&lt;CR&gt;
</pre>
ack recherche par défaut dans le répertoire courant. Il est pratique de configurer son .ackrc pour limiter le bruit en excluant certains fichiers ou répertoires.
<pre class="prettyprint">
--ignore-dir=target
</pre>
<p>Dans IntelliJ Idea, c'est <i>Edit | Find | Find in Path</i>.
</p>

<h2>Ouvrir un fichier</h2>
<p>
Le plugin <a href="https://github.com/kien/ctrlp.vim">CtrlP</a> ajoute, entre autres, une commande <code>:CtrlP</code> qui ouvre un fichier à partir de son nom, en mode fuzzy. ctrlp trouve la racine du projet en recherchant le répertoire <code>.git</code>. Pour exclure certains fichiers ou répertoires, on utilise le <code>wildignore</code> de vim :
<pre class="prettyprint">
set wildignore=**/target/*
</pre>
<p>
Dans IntelliJ Idea, c'est <i>Navigation | File</i>.
</p>

<h2>Compilation</h2>
<p>
Je ne cherche pas à compiler depuis Vim, j'ouvre un autre terminal pour cela.
</p>
<h2>Consulter la doc</h2>
<p>
Le plugin <a href="https://github.com/mdreves/vim-scaladoc">scaladoc</a> ouvre la Scaladoc avec la commande <code>:Scaladoc</code>.
</p>

<h2>Les fonctionnalités manquantes</h2>
<p>Voici les fonctionnalités qui n'ont pas d'équivalent dans vim, classées par ordre d'utilité :</p>
<ul>
    <li>complétion contextuelle : c'est la fonctionnalité qui manque le plus lorsqu'on l'on est habitué à travailler dans un IDE, avec un langage statiquement typé. Il semble exister une possibilité avec le plugin neocomplcache ;</li>
    <li>connaître le type inféré sous le curseur ;</li>
    <li>refactoring automatique ;</li>
    <li>live template : à creuser, il semble exister une possibilité avec le plugin snipmate ;</li>
    <li>debug : il n'est pas possible de mettre des points d'arrêt ;</li>
    <li>un vérificateur de syntaxe, cela semble possible avec syntastic.</li>
</ul>
<h2>Sources</h2>
<ul>
    <li><a href="http://latestbuild.net/scala-ctags-and-vim-tagbar">scala-ctags-and-vim-tagbar</a></li>
    <li><a href="http://kien.github.io/ctrlp.vim/">Documentation du plugin ctrlp.vim</a></li>
    <li><a href="http://majutsushi.github.io/tagbar/">Documentation du plugin tagbar</a></li>
</ul>
