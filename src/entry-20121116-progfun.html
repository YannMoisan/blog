$title=Functional Programming Principles in Scala
$description=Functional Programming Principles in Scala
-----
<p>Le cours de <a href="https://www.coursera.org/course/progfun">programmation fonctionnelle en Scala</a> sur coursera se termine. Il est assuré par Martin Odersky, qui n'est rien moins que l'inventeur du langage. Le cours, avec ces 50.000 inscrits, a rencontré un franc succès, révélateur de l'émulation autour de ce langage.</p>
<p>Il a duré 7 semaines, à raison de 5-7 heures par semaine. J'en suis très satisfait. Chaque semaine, il y a 2 grandes parties : un cours théorique en video et des exercices portant, bien évidemment, sur le contenu du cours. Les videos sont en anglais mais relativement simples à comprendre et le discours est appuyé par des slides. De plus, le professeur est un excellent pédagogue. Les exercices, parfois ardus, permettent, au fur et à mesure, d'appréhender un mode de raisonnement fonctionnel. Et un astucieux système de notation en quasi temps réel permet d'avoir un feedback rapide sur son travail.</p>
<p>Une nouvelle thématique est abordée chaque semaine. Voici le programme semaine par semaine, avec quelques points qui ont retenu mon attention, en tant que développeur Java :</p>
<ul>
    <li>Semaine 1 : Fonctions et Evaluations
    <p>Le mécanisme de substitution et le lambda-calcul.</p>
    <p>La possibilité de choisir entre call by value (évalue les arguments avant d'appeler la fonction) et call by name (évalue la fonction en premier, et ensuite les arguments si besoin). En Java, il n'y a que du call by value ...</p></li>
    <li>Semaine 2 : Les fonctions d'ordre supérieur (i.e. une fonction qui prend en paramètre une fonction ou qui retourne une fonction)
    <p>La récursivité, la recursivité terminale et l'astuce de l'accumulateur</p>
    <p><a href="http://fr.wikipedia.org/wiki/Curryfication">La curryfication</a></p></li>
    <li>Semaine 3 : Données et abstraction
    <p>L'associativité de l'opérateur est determinée par le dernier caractère (<code>:</code> pour associativité à droite). En Java, seul l'opérateur <code>=</code> est associatif à droite.</p>
    <p>En Scala, tout est objet (pas de type primitif comme en Java). La hiérarchie des objets est : <code>Any</code>, <code>AnyVal</code>, <code>AnyRef</code></p></li>
    <li>Semaine 4 : Type et pattern matching
    <p>Les fonctions sont des objets avec une méthode apply. A creuser <a href="http://gleichmann.wordpress.com/2011/01/09/functional-scala-turning-methods-into-functions/">eta expansion</a>.<p>Les deux formes de polymorphisme : subtype et generics - Les types paramétrés s'écrivent <code>MaClasse[T]</code> (au lieu de <code>MaClasse&lt;T&gt;</code> en Java).</p>
    <p>La notion de variance. Etant donné que <code>A &lt;: B</code>, si <code>C[A] &lt;: C[B]</code> C est covariant. Un objet immuable peut-être covariant. Pour rappel, en Java, Array est mutable et covariant, ce qui peut entrainer des erreurs à l'execution (<code>ArrayStoreException</code>). Une bonne pratique : Les fonctions doivent être contravariant dans leurs types d'argument et covariant dans leurs types de résultats (<code>trait Function[-T, +U]{ def apply(x: T): U }</code>).</p>
    <p>Le pattern matching</p></li>
    <li>Semaine 5 : Les listes
    <p><code>xs ++ ys</code> (concatenation) est équivanlent à : <code>(xs foldRight ys)(_ :: _)</code></p></li>
    <li>Semaine 6 : Les collections
    <p><code>flatten</code> est équivalent à <code>foldRight (_++_)</code></p>
    <p><code>xs flatMap f est équivalent à (xs map f).flatten</code></p>
    <p>Un exemple pour calculer un produit scalaire en une seule ligne montre la richesse de l'API : <code>for ((x,y)&lt;-xs zip ys) yield x*y).sum</code></p>
    <p>les for-comprehension (un sucre syntaxique pour les méthodes map, flatMap, filter)</p>
    <p><code>for (x &lt;- e1) yield e2</code> est équivalent à <code>e1.map(x =&gt; e2)</code></p>
    <p><code>for (x &lt;- e1 if f) yield e2</code> est équivalent à <code>for (x &lt;- e1.filter(x =&gt; f)) yield e2</code></p>
    <p><code>for (x &lt;- e1; y &lt;- e2) yield e3</code> est équivalent à <code>e1.flatMap(x =&gt; for (y &lt;  - e2) yield e3)</code></p>
    <p>le trait <code>Option</code>.</p>
    <p>une instance de <code>Map</code> est une fonction partielle. <a href="http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html">Un article sur le sujet</a></p>
    <p>Le pattern Iterator est un concept imperatif</p></li>
    <li> Semaine 7 : L'evaluation lazy : les streams ...</li>
</ul>
<p>Avec ce cours, j'ai clairement progressé en Scala, et appris à raisonner de manière plus fonctionnel. Je recevrai même un certificat grâce à ma note de 80/80. Il reste cependant pleins de sujets à creuser. Voici d'ailleurs une liste glanée au fil de mes pérégrinations sur la toile, pour donner des idées à ceux qui voudraient aller plus loin :</p>
<ul>
    <li>SBT, l'outil de build utilisé par le cours, pour remplacer définitivement Maven ?</li>
    <li><a href="http://akka.io/">Akka</a>, un framework d'Actor, pour faciliter l'écriture de code concurrent</li>
    <li><a href="http://www.playframework.org/">Play</a>, un framework web</li>
    <li>un article de Jonas Boner sur le <a href="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/">Cake pattern</a>, pour implémenter l'injection de dépendances</li>
    <li>Une <a href="http://www.youtube.com/watch?feature=player_embedded&v=ZasXwtTRkio">video</a> sur l'injection de dépendances avec une monade Reader</li>
    <li>un article sur <a href="http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html">le trampoline</a>, pour optimiser la récursion</li>
    <li>les <a href="http://en.wikipedia.org/wiki/Monad_%28functional_programming%29">monades</a>, pour comprendre ce qui ce cache derrière l'obscure formule : Monads are just monoids in the category of endofunctors.</li>
    <li><a href="https://github.com/NICTA/scoobi">scoobi</a>, pour écrire des jobs MapReduce Hadoop en Scala</li>
    <li><a href="https://github.com/twitter/scalding">scalding</a>, pour écrire des jobs MapReduce Hadoop en Scala</li>
    <li>et continuer à pratiquer avec les <a href="http://aperiodic.net/phil/scala/s-99/">99 scala problèmes</a></li>
    <li>et pour les parisiens, il y a le <a href="https://groups.google.com/forum/?fromgroups#!forum/paris-scala-user-group">PSUG.</a></li>
</ul>
