---
title: Vim comme IDE Scala
description: Vim comme IDE Scala
layout: blog
---
<p>Après un an de pratique, voici une mise à jour de mon article sur Vim et
Scala.<p>
Je suis en cours de conversion de IntelliJ Idea vers Vim, pour développer en Scala. J'ai déjà brièvement parlé de Vim et Scala <a href="tdd-en-scala.html">dans ce billet</a>.
Le but de ce billet est de présenter comment configurer Vim pour avoir les principales fonctionnalités d'un IDE.
L'utilisation de Vim en entreprise me semble assez marginale en France, comme s'en étonne Bodil Stokke dans ce tweet :
</p>
<blockquote>« Enterprise guys give me such a feeling of disconnect: they're arguing IDEA vs Eclipse instead of vim vs emacs. »</blockquote>
<p>Il me paraît donc important de mentionner que moult développeurs talentueux utilisent Vim.
En voici quelques-uns qui sont pour moi une source d'inspiration :
</p>

<ul>
    <li><a href="https://twitter.com/derekwyatt">Derek Wyatt</a>, auteur de Akka Concurrency ;</li>
    <li><a href="https://twitter.com/spf13">Steve Francia</a>, évangeliste 10gen ;</li>
    <li><a href="https://twitter.com/paulrouget">Paul Rouget</a>, développeur Mozilla ;</li>
    <li><a href="https://twitter.com/ornicar">Thibault Duplessis</a>, développeur Scala.</li>
</ul>

<h2>Coloration syntaxique</h2>
<p>
Il suffit d'installer le plugin <a
    href="https://github.com/derekwyatt/vim-scala">vim-scala</a>. Ce plugin gère
aussi l'indentation et la détection des fichiers scala. Il permet aussi de
classer les import avec la commande <code>:SortImportScala</code>.
Seul bémol, l'indentation automatique avec <code>=</code> ne fonctionne pas
correctement, notamment avec l'accolade fermante. Mais nous verrons un contournement au paragraphe formateur.</p>

<h2>Navigation dans le code source</h2>
<p>
Ctags est un outil classique du monde Unix. Il ne supporte pas Scala par défaut, mais il est très simple d'ajouter ce support en créant/modifiant un fichier <code>~/.ctags</code>. Vous pouvez récuperer le fichier <a href="http://latestbuild.net/scala-ctags-and-vim-tagbar">ici</a>. On peut maintenant sauter à la définition du terme sous le curseur en tapant <code>&lt;C-]&gt;</code>.</p>
<p>Alors que l'IDE recompile de manière transparente le code pour permettre la complétion, il faut lancer ctags à la main. Le mapping suivant permet d'effectuer cela en tapant <code>F5</code>.
<pre class="prettyprint">
map &lt;F5&gt; :!ctags -R
</pre>
<p>Le plugin <a href="https://github.com/majutsushi/tagbar/">tagbar</a> donne un aperçu de la structure du code source du fichier courant, comme la vue <i>structure</i> d'IntelliJ Idea. 
Le langage Scala n'est pas supporté par défaut. Mais la configuration est
apporté par le plugin <a
    href="https://github.com/derekwyatt/vim-scala/blob/master/ftplugin/scala.vim#L139">vim-scala</a>.
<p>
J'ai noté deux limites : tagbar confond méthode et variable, et les méthodes ne sont pas regroupées par objet.
</p>

<h2>Complétion</h2> 
<p>
La complétion de code est native dans Vim. Les commandes sont <code>&lt;C-n&gt;</code> pour la complétion classique et <code>&lt;C-x&gt;&lt;C-]&gt;</code> pour la complétion basée sur les tags
</p>
<p>Cependant, je vous recommande d'installer <a
    href="https://github.com/Shougo/neocomplete.vim">neocomplete</a> qui offre la
completion lors de la frappe (<i>as-you-typed</i>).</p>

<h2>Snippet</h2>
<p>
Le plugin <a href="https://github.com/Shougo/neosnippet.vim">neosnippet</a>
offre des snippets de code et s'intègre très bien avec neocomplete.
C'est l'équivalent des Live Templates avec IntelliJ.
</p>

<h2>Syntastic</h2>
<p>
Le plugin <a href="https://github.com/scrooloose/syntastic">syntastic</a> offre la vérification du code Scala à la volée. 
Il utise <a
    href="https://github.com/scrooloose/syntastic/blob/master/syntax_checkers/scala/scalac.vim">le
    parser de scalac</a> et est assez lent.
Je préfére utiliser la méthode décrite dans compilation.
</p>

<h2>Rechercher dans le projet</h2>
<p>
ack est un meilleur grep. Le plugin <a href="https://github.com/mileszs/ack.vim">Ack.vim</a> ajoute une commande <code>:Ack [options] {pattern} [{directory}]</code> qui permet de chercher récursivement <i>pattern</i> dans <i>directory</i>. Les résultats alimentent le quick fix de Vim. Les mappings suivant permettent de faciliter la navigation dans les occurences du quick fix.
<pre class="prettyprint">
nnoremap &lt;silent&gt; [q :cprevious&lt;CR&gt;
nnoremap &lt;silent&gt; ]q :cnext&lt;CR&gt;
nnoremap &lt;silent&gt; [Q :cfirst&lt;CR&gt;
nnoremap &lt;silent&gt; ]Q :clast&lt;CR&gt;
</pre>
ack recherche par défaut dans le répertoire courant. Il est pratique de configurer son .ackrc pour limiter le bruit en excluant certains fichiers ou répertoires.
<pre class="prettyprint">
--ignore-dir=target
</pre>
<p>Dans IntelliJ Idea, c'est <i>Edit | Find | Find in Path</i>.
</p>

<h2>Ouvrir un fichier</h2>
<p>
Le plugin <a href="https://github.com/kien/ctrlp.vim">CtrlP</a> ajoute, entre autres, une commande <code>:CtrlP</code> qui ouvre un fichier à partir de son nom, en mode fuzzy. ctrlp trouve la racine du projet en recherchant le répertoire <code>.git</code>. Pour exclure certains fichiers ou répertoires, on utilise le <code>wildignore</code> de vim :
<pre class="prettyprint">
set wildignore=**/target/*
</pre>
<p>
Dans IntelliJ Idea, c'est <i>Navigation | File</i>.
</p>

<h2>Compilation</h2>
<p>
Je ne cherche pas à compiler depuis Vim, j'ouvre un autre terminal avec SBT pour cela.
Il existe cependant un wrapper SBT qui permet de récupérer les erreurs de
compilation dans le quickfix de Vim.</p>

<h2>Consulter la doc</h2>
<p>
Le plugin <a href="https://github.com/mdreves/vim-scaladoc">scaladoc</a> ouvre la Scaladoc avec la commande <code>:Scaladoc</code>.
</p>

<h2>Le formateur syntaxique</h2>
<p>
Vim permet de configurer un programme externe pour formater le texte avec
l'opérateur gq. <a href="https://github.com/mdr/scalariform">scalariform</a> est
un formatteur pour Scala. Il suffit juste d'ajouter la ligne suivante dans son
<code>.vimrc</code> 
</p>
<pre class="prettyprint">
    au BufEnter *.scala setl formatprg=java\ -jar\ ~/scalariform.jar\ --stdin\ --stdout
</pre>

<h2>Les fonctionnalités manquantes</h2>
<p>Voici les fonctionnalités qui n'ont pas d'équivalent dans vim, classées par ordre d'utilité :</p>
<ul>
    <li>complétion contextuelle : c'est la fonctionnalité qui manque le plus lorsqu'on l'on est habitué à travailler dans un IDE, avec un langage statiquement typé. Il semble exister une possibilité avec le plugin neocomplcache ;</li>
    <li>connaître le type inféré sous le curseur ;</li>
    <li>refactoring automatique ;</li>
    <li>debug : il n'est pas possible de mettre des points d'arrêt ;</li>
</ul>
<h2>Reste à faire</h2>
<p>
Tester use <a href="https://github.com/ornicar/scalariver">scalariver</a> pour
améliorer les performances de scalariform.
</p>

<h2>Sources</h2>
<ul>
    <li><a href="http://latestbuild.net/scala-ctags-and-vim-tagbar">scala-ctags-and-vim-tagbar</a></li>
    <li><a href="http://kien.github.io/ctrlp.vim/">Documentation du plugin ctrlp.vim</a></li>
    <li><a href="http://majutsushi.github.io/tagbar/">Documentation du plugin tagbar</a></li>
    <li><a
        href="http://aloiscochard.blogspot.fr/2013/02/quick-bug-fixing-in-scala-with-sbt-and.html">Quick bug fixing in Scala with SBT and Vim</a></li>
</ul>
