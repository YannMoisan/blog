---
title: "Playing with Docker and nginx : from multi-domain to multi-container"
description: "Use Docker to host multiple sites, in an isolated way, each on in his own container."
layout: blog
---
<h1>Context</h1>

<p>I've started to use docker at work and I have a personal server that hosts 2
websites on a single nginx instance, with 2 virtual hosts configured (a.k.a. server). So the idea is to upgrade the architecture
to embrace the docker way, and also improve my knowledge about docker.</p>

<p>Each website should run on its own container, and a reverse proxy will route the traffic.</p>

<h1>Implementation</h1>

<h2>Step1</h2>

<p>Let's create a new project, divided in 3 folders : site1, site2, proxy. One folder for each container.</p>

<pre class="prettyprint"><code>proxy
  Dockerfile
  conf
    conf.d
      site1.conf
      site2.conf
site1
  Dockerfile
  index.html
site2
  Dockerfile
  index.html
</code></pre>

<p>Here is the content of <code>site1.conf</code>, the reverse proxy configuration for site1 :</p>

<pre class="prettyprint"><code>server {
    listen       80;
    server_name  site1;

    location / {
        proxy_pass   http://192.168.59.103:8080/;
    }
}
</code></pre>

<p>Let's run the containers :</p>

<pre class="prettyprint"><code>docker run -d -p 8080:80 ymn/site1
docker run -d -p 8081:80 ymn/site2
docker run -d -p 80:80 ymn/proxy
</code></pre>

<p>I can test direct access</p>

<pre class="prettyprint"><code>curl "http://docker:8080/"
curl "http://docker:8081/"
</code></pre>

<p>and proxified access</p>

<pre class="prettyprint"><code>curl "http://site1"
curl "http://site2"
</code></pre>

<p>What could be improved :</p>

<ul>
<li><em>proxy_pass</em> contains an hardcoded IP adress</li>
<li>The 3 containers should be started manually</li>
<li>The ports of site container are publicly exposed</li>
</ul>


<h2>Step2</h2>

<p>To avoid exposing ports, Docker allows to <a href="http://docs.docker.com/userguide/dockerlinks/">link containers together</a>.</p>

<p>Here is how to run containers</p>

<pre class="prettyprint"><code>docker run -d --name site1 ymn/site1
docker run -d --name site2 ymn/site2
docker run -d -p 80:80 --name proxy --link site1 --link site2 ymn/proxy
</code></pre>

<p>As you can see, containers now have names, because Docker linking is
based on the name.</p>

<p>Here is the new configuration for the proxy</p>

<pre class="prettyprint"><code>server {
    listen       80;
    server_name  site1;

    location / {
        proxy_pass   http://site1/;
    }
}
</code></pre>

<p>With the link, the proxy container know how to connect to site1. In fact,
Docker adds a host entry for site1 to the <code>/etc/hosts</code> of the proxy container.</p>

<h2>Step3</h2>

<p>Command lines are now very long and it becomes painfull to run the whole things.
Hopefully, there is a tool in the fast-growing Docker ecosystem that will help
us : <a href="https://www.docker.com/docker-compose">docker-compose</a>.</p>

<p>We just have to define our multi-container application with a configuration file in YAML to describe how to run our 3 containers</p>

<pre class="prettyprint"><code>proxy:
  build: proxy
  ports:
  - 80:80
  links:
  - site1
  - site2
site1:
  image: ymn/site1
site2:
  image: ymn/site2
</code></pre>

<p>And we can run all containers with a single command : <code>docker-compose up</code></p>

<h2>Step 4</h2>

<p>The setup is now quite good. But there is still way to improve. Docker expose a <a href="http://docs.docker.com/reference/api/docker_remote_api/">remote API</a> that allows to automate many tasks. So some projects leverage this API, like <a href="https://github.com/jwilder/nginx-proxy">nginx-proxy</a> which  generate automatically the config of the proxy:</p>

<pre class="prettyprint"><code>docker run -d -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
docker run -d -e VIRTUAL_HOST=site1 ymn/site1
docker run -d -e VIRTUAL_HOST=site2 ymn/site2
</code></pre>

<h1>Links</h1>

<ul>
<li>http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/</li>
</ul>

</body>
</html>
