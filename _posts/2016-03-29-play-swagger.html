---
title: Add a swagger documentation on a Play application
description: Add a swagger documentation on a Play application
layout: blog
---
<p>
The starting point of this post is the need to document an existing REST APIs. I want the
documentation to live with my code because I think it's the only way to have an up-to-date doc.
Swagger seems to be a defacto standard. This post is not a tutorial, it's just
to share some issues I faced.
So let's get the party started.
</p>

<p>
I use PlayFramework and Scala. Thankfully, an integration already exists :
<a href="https://github.com/swagger-api/swagger-play">play-swagger</a>. 
Play-swagger relies mainly on annotations. I'm not a big fan of annotations,
maybe because they remind me of my long years of
Java EE development. Last point, my APIs uses snake case and because
swagger-core introspect fields, the default behaviour won't work as expected.
</p>

<h2>
    Tuple serialization
</h2>
<p>
Some of my services returns <code>Tuple</code>, so I have a custom <code>Writes</code>
</p>

<pre class="prettyprint"><code>
  implicit val tupleWrites :  Writes[(Int, String)] = Writes[(Int, String)] {
    case (id, action) =>
        Json.obj(
          "tip_id" -> id,
          "action" -> action
        )
  }
</code></pre>

<p>
Swagger uses the return type of your operation method. It detects <code>ActionAnyContent</code> or
<code>ActionJsValue</code>, depending on the BodyParser you use, that is never what you want.
(I don't understand how the erroneous concatenation happens between the type <code>Action</code> and the type
parameter <code>JsValue</code>). 
</p>
<pre class="prettyprint"><code>
"responses": {
  "200": {
    "description": "successful operation",
    "schema": {
      "$ref": "#/definitions/ActionAnyContent"
    }
  }
}
</code></pre>

<p>
So we have to explicitly set the response class
with the following annotation :
</p>

<pre class="prettyprint"><code>
@ApiOperation(response = classOf[Tuple2[Int, String]])
</code></pre>

<p>
Due to Java type erasure, swagger will only generate :
</p>

<pre class="prettyprint"><code>
"definitions": {
    "Tuple2": {
      "type": "object",
      "properties": {
        "_1": {
          "type": "object"
        },
        "_2": {
          "type": "object"
        }
      }
    },
</code></pre>

<p>
In fact, play-swagger has no idea how the Tuple is serialized and I came up with a trick to
generate the documentation by creating a fake case class.
</p>

<pre class="prettyprint"><code>
@ApiModel(value="Tip id and action")
case class TipIdAndAction(
  @ApiModelProperty(name="tip_id", required=true) tipId: Id,
  @ApiModelProperty(required=true) action: String)
</code></pre>

<p>
The annotation <code>@ApiModelProperty</code> is used to specify the name
because I use snake case in JSON and camel case in Scala.
</p>

<p>
Lastly, this annotation should be added on the action :
</p>

<pre class="prettyprint"><code>
@ApiOperation(response = classOf[TipIdAndAction])
</code></pre>

<p>
In fact, there are some cases where you can have different representation of a
model, at least for read and write. For example,
a timestamp is forbidden at creation but mandatory during retrieval. 
It seems impossible to do that with swagger annotations.
</p>

<p>
And now, I have to maintain the mapping and the case class. It seems boring and
error prone. So let's get rid of the Tuple and use case class instead.
</p>

<pre class="prettyprint"><code>
implicit val actionWrites :  Writes[TipIdAndAction] = Writes[TipIdAndAction] { ta =>
Json.obj(
  "tip_id" -> ta.tipId,
  "action" -> ta.action
)
}
</code></pre>

<p>
Either I can modify my service to return a <code>TipIdAndAction</code> or I have to transform a
Tuple into a <code>TipIdAndAction</code>. At first sight, the last idea seems like the return
of the DTO antipattern, a really bad idea. Nevertheless, I'd prefer that over
polluting my domain model with swagger annotations.
</p>

<p>
     I can also use <a
         href="https://playframework.com/documentation/2.4.x/ScalaJsonInception">JSON
         Macro inception</a> and <a
         href="https://github.com/tototoshi/play-json-naming">play-json-naming</a> to avoid writing the <code>Writes</code>
     class. Unfortunately, I still need annotations on the case class. So now, all the
     boilerplate is just for swagger purpose. Even if Macro Inception is great,
     beware that a simple renaming of a property will change the JSON output, so
     the contract of your API.
</p>

<pre class="prettyprint"><code>
  implicit val actionWrites : Writes[TipIdAndAction] = JsonNaming.snakecase(Json.writes[TipIdAndAction])
</code></pre>

<h2>Nested annotation</h2>
<p>
for @ApiResponses, the syntax mentioned in the swagger doc triggers a
compilation issue for an unknown reason (let me know if you know) :
</p>

<pre class="prettyprint"><code>
@ApiResponses(value = { 
      @ApiResponse(code = 400, message = "Invalid ID supplied", 
                   responseHeaders = @ResponseHeader(name = "X-Rack-Cache", description = "Explains whether or not a cache was used", response = Boolean.class)),
      @ApiResponse(code = 404, message = "Pet not found") })
</code></pre>

<h2>
    Manage HTTP Header
</h2>
<p>
For HTTP Header, like <code>Accept-Language</code>, you have to copy/paste the
following on each operation that deals with this header.
</p>
<pre class="prettyprint"><code>
  new ApiImplicitParam(
    name = "Accept-Language", 
    value = "language for the tip in the response", 
    defaultValue = "en", 
    required = false, 
    paramType = "header", 
    dataType="string"
  )
</code></pre>

<p>
Finally, I still have two questions :
</p>

<ul>
    <li>
        <a href="http://stackoverflow.com/questions/36306341/how-do-you-model-an-empty-body-with-swagger-annotation">How do you model an empty body</a>
    </li>
    <li>
        <a href="http://stackoverflow.com/questions/36304732/swagger-ui-doesnt-display-the-response-model-for-a-400">Why swagger-ui doesn't display the response model for an alternate response</a>
    </li>
</ul>


<h2>Conclusion</h2>
<p>
Using swagger with Play is a pain. It forces you to break the DRY rule. But it
remains better than writing swagger with a tool like Swagger Editor, due to the
colocation of the spec with the code.
Here are some points of attention :
</p>
<ul>
    <li>
        Beware of always mentioning an explicit response class
    </li>
    <li>
        Don't use snake case to benefit from swagger automatic generation
    </li>
    <li>
        Don't use Tuples
    </li>
    <li>
        Don't pollute your domain model with annotations
    </li>
</ul>

