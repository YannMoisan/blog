---
title: for-comprehension en Scala 
description: Explication du for-comprehension en Scala par l'exemple
layout: blog
---
<p>Scala possède un mécanisme très puissant mais pas simple à appréhender : for-comprehension. Le but de ce billet est d'aborder ce sujet par l'exemple avec les <code>List</code>. J'illustre le propos avec des exemples que vous pouvez exécuter dans le REPL pour vous exercer.</p>

<h2><code>map</code></h2>
<p>La méthode <code>map</code> permet d'appliquer une fonction à tous les éléments d'une liste.</p>
<pre class="prettyprint">
scala&gt; List(1, 2, 3).map(_ * 2)
res0: List[Int] = List(2, 4, 6)
</pre>
<p>Les for-comprehensions ne sont qu'un sucre syntaxique. Voici le cas le plus simple :</p>
<p><code>for (x &lt;- e1) yield e2</code> est équivalent à <code>e1.map(x =&gt; e2)</code></p>
<p>Le premier exemple peut donc être réécrit :</p>
<pre class="prettyprint">
scala&gt; for (x &lt;- List(1, 2, 3)) yield x * 2
res1: List[Int] = List(2, 4, 6)
</pre>

<h2>flatten</h2>
<p>La méthode <code>flatten</code> permet d'aplatir une List, c.-à-d. transformer une List de List en List. Le plus simple est de voir un exemple :</p>
<pre class="prettyprint">
scala&gt; List(List(1, 2), List(3, 4), List(5, 6)).flatten
res2: List[Int] = List(1, 2, 3, 4, 5, 6)
</pre>

<h2>flatMap</h2>
<p>La méthode <code>flatMap</code> permet de combiner les deux méthodes précédentes :</p>
<p><code>xs flatMap f</code> est équivalent à <code>(xs map f).flatten</code></p>
<pre class="prettyprint">
scala&gt; List(1, 2, 3).flatMap(i =&gt; ((1 to i).toList))
res0: List[Int] = List(1, 1, 2, 1, 2, 3)
</pre>
<p>Revoyons la scène au ralenti :</p>
<pre class="prettyprint">
scala&gt; List(1, 2, 3).map(i =&gt; (1 to i).toList)
res1: List[List[Int]] = List(List(1), List(1, 2), List(1, 2, 3))

scala&gt; res1.flatten
res2: List[Int] = List(1, 1, 2, 1, 2, 3)
</pre>

<h2>for-comprehension</h2>
<p>C'est le moment de venir au cœur du sujet. Un for-comprehension ressemble à une boucle mais le mécanisme est en fait beaucoup plus puissant.</p>
<pre class="prettyprint">
scala&gt; for (x &lt;- List(1, 2); y &lt;- List(3, 4)) yield (x, y)
res0: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
</pre>
<p>Comme pour le premier exemple, c'est un sucre syntaxique :</p>
<p><code>for (x &lt;- e1; y &lt;- e2) yield e3</code> est équivalent à <code>e1.flatMap(x =&gt; for (y &lt; - e2) yield e3)</code></p>
<pre class="prettyprint">
scala&gt; List(1, 2).flatMap(x =&gt; List(3, 4).map(y =&gt; (x, y)))
res1: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
</pre>
<p>Interessons nous à fonction imbriquée :</p>
<pre class="prettyprint">
scala&gt; (x: Int) =&gt; List(3, 4).map(y =&gt; (x, y))
res2: Int =&gt; List[(Int, Int)] = <function1>
</pre>
<p>C'est donc une fonction qui prend un Int et renvoie une liste de paires. Voici le résultat de l'exécution quand on passe 1 en paramètre :</p>
<pre class="prettyprint">
scala&gt; res2(1)
res3: List[(Int, Int)] = List((1,3), (1,4))
</pre>
<p>On peut ainsi substituer le résultat dans l'expression initiale, ce qui donne :</p>
<pre class="prettyprint">
scala&gt; List(1, 2).flatMap(x =&gt; List((x, 3), (x, 4)))
res4: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
</pre>
<p>Comme précédemment, revoyons la scène au ralenti :</p>
<pre class="prettyprint">
scala&gt; List(1, 2).map(x =&gt; List((x, 3), (x, 4)))
res5: List[List[(Int, Int)]] = List(List((1,3), (1,4)), List((2,3), (2,4)))
</pre>
<pre class="prettyprint">
scala&gt; res5.flatten
res6: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
</pre>
<p>Il est à noter que for-comprehension permet aussi de filtrer, avec des guards.</p>
