---
title: Java 7 depuis les tranchées
description: Java 7 depuis les tranchées, un retour d'expérience de l'utilisation de Java 7 au quotidien
layout: blog
---
<p>Le but de ce billet est de fournir un retour d'expérience sur Java 7, que j'utilise sur mon projet actuel. Il aura fallu attendre 5 ans avant la sortie de cette version majeure qui apporte de <a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#changes">nouvelles fonctionnalités</a>. Il serait dommage de ne pas l'utiliser !</p>
<h2>Les nouvelles fonctionnalités</h2>
<p>Voici celles que j'utilise et que trouve très pratiques :</p>
<ul>
    <li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/try-with-resources.html">try-with-resources</a> qui permet de fermer automatiquement les ressources.</li>
    <li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html">catch multiple</a> qui permet d'avoir d'attraper plusieurs exceptions dans un seul bloc catch.</li>
    <li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/type-inference-generic-instance-creation.html">diamond operator</a> qui permet d'omettre la déclaration des types génériques, le compilateur réalisant de l'inférence de type.</li>
    <li><a href="http://openjdk.java.net/projects/nio/javadoc/java/nio/file/Path.html">java.nio.file.Path</a> qui remplace avantageusement la classe File en offrant une API plus riche.</li>
    <li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html">java.util.Objects</a> qui est une classe utilitaire (étonnament ressemblante avec la classe <code>Objects</code> de guava) fournissant des méthodes de base pour travailler avec des <code>Object</code> : <code>equals</code>, <code>hashCode</code>, <code>toString</code>. A noter, Eclipse 3.7 ne tire pas partie de ces méthodes lors de la génération des méthodes <code>equals</code> et <code>hashCode</code>.</li>
</ul>
<h2>Une incompatibilité avec Surefire</h2>
<p>J'ai rencontré l'erreur suivante : <code>java.lang.VerifyError: Expecting a stackmap frame at branch target</code>. Heureusement, il est possible de contourner en passant l'argument <code>-XX:-UseSplitVerifier</code> à la JVM. Voici la configuration pour les utilisateurs de Maven:</p>
<pre class="prettyprint">
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.12&lt;/version&gt;
    &lt;configuration&gt;
        &lt;argLine&gt;-XX:-UseSplitVerifier&lt;/argLine&gt;
        &lt;skipTests&gt;false&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</pre>
<h2>Des faux positifs dans Sonar</h2>
<p>Nous utilisons Sonar 2.13 et les nouveautés du langage provoque des faux positifs: l'instruction <code>try-with-resource</code> provoque une violation Inner Assignement dans Checkstyle.</p>
