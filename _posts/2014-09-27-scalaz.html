---
title: Scalaz from the trenches
description: Scalaz from the trenches
layout: blog
---
<h1>
<a name="user-content-scalaz" class="anchor" href="#scalaz" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scalaz</h1>

<p>The aim of this page is to show the use of <a href="https://github.com/scalaz/scalaz">Scalaz</a> on the project.
Scalaz defines itself as an extension to the core Scala library for functional programming</p>

<h2>
<a name="user-content-option" class="anchor" href="#option" aria-hidden="true"><span class="octicon octicon-link"></span></a>option</h2>

<p>Scalaz pimp your options.</p>

<pre class="prettyprint">scala&gt; 1.some.toSuccess("error")
res32: scalaz.Validation[String,Int] = Success(1)

scala&gt; None.toSuccess("error")
res33: scalaz.Validation[String,A] = Failure(error)
</pre>

<h2>
<a name="user-content-sequence" class="anchor" href="#sequence" aria-hidden="true"><span class="octicon octicon-link"></span></a>sequence</h2>

<p>Scalaz API is hard to read :</p>

<pre class="prettyprint">trait TraverseOps[F[_], A] extends scala.AnyRef with scalaz.syntax.Ops[F[A]] {
  final def sequence[G[_], B](implicit ev : scalaz.Leibniz.===[A, G[B]], G : scalaz.Applicative[G]) : G[F[B]] = { /* compiled code */ }
}
</pre>

<p>Here is some explanation from <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/TraverseUsage.scala">Scalaz Traverse examples</a> :</p>

<pre class="prettyprint">// An easy to understand first step in using the Traverse typeclass
// is the sequence operation, which given a Traverse[F] and
// Applicative[G] turns F[G[A]] into G[F[A]]. This is like "turning
// the structure 'inside-out'":
</pre>

<p>So, it allows to do simple things :</p>

<pre class="prettyprint">scala&gt; List(Option(1), Option(2)).sequence
res8: Option[List[Int]] = Some(List(1, 2))

scala&gt; List(Option(1), None).sequence
res9: Option[List[Int]] = None
</pre>

<pre class="prettyprint">// The effect of the inner Applicative is used, so in the case of
// the Option applicative, if any of the values are None instead of
// Some, the result of the entire computation is None:
</pre>

<p>Obviously, it can be done without Scalaz by implementing a <code>sequence</code> method :</p>

<pre class="prettyprint">def sequence[A](l: List[Option[A]]): Option[List[A]] =
  l.foldRight(Some(Nil: List[A]):Option[List[A]])((oa, ola) =&gt; oa.flatMap(a =&gt; ola.map(la =&gt; a :: la)))
</pre>

<p>But it seems like reinventing the wheel, and it will only work for <code>Option</code>, and not for all <code>Applicative</code>s.</p>

<h2>
<a name="user-content-validation" class="anchor" href="#validation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Validation</h2>

<p>In scala, we use <code>Either</code> as a return type to represent a method that can fail. Unfortunately, the type <code>Either</code> has some limitations and doesn't allow to collect a list of errors.
Let's introduce new datatypes <code>Validation</code> to resolve this issue :</p>

<pre class="prettyprint">scala&gt; def f = { x : String =&gt; if (!x.toLowerCase.equals(x)) "only lowercase allowed".failure[String] else "ok2".success }
f: String =&gt; scalaz.Validation[String,String]

scala&gt; def g = { x : String =&gt; if (x.contains(" ")) "no space allowed".failure[String] else "ok1".success[String] }
g: String =&gt; scalaz.Validation[String,String]

scala&gt; (f("A b") |@| g("A b")) {_ + _}
res28: scalaz.Unapply[scalaz.Apply,scalaz.Validation[String,String]]{type M[X] = scalaz.Validation[String,X]; type A = String}#M[String] = Failure(only lowercase allowedno space allowed)
</pre>

<p>Here is some explanation from <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ApplyUsage.scala">Scalaz Apply examples</a> :</p>

<pre class="prettyprint">// |@| is refered to as "applicative builder", it allows you to
// evaluate a function of multiple arguments in a context, similar
// to apply2, apply3, apply4, etc:
</pre>

<h2>
<a name="user-content-kleisli" class="anchor" href="#kleisli" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kleisli</h2>

<p>It allows to combine monadic functions</p>

<pre class="prettyprint">scala&gt; def f = { x : Int =&gt; Option(x+1) }
f: Int =&gt; Option[Int]

scala&gt; def g = { x : Int =&gt; Option(x*2) }
g: Int =&gt; Option[Int]

scala&gt; Kleisli(f) &gt;=&gt; Kleisli(g)
res10: scalaz.Kleisli[Option,Int,Int] = scalaz.KleisliFunctions$$anon$17@6442084f

scala&gt; res10(3)
res11: Option[Int] = Some(8)
</pre>

<p>Obviously, it can also be done without Scalaz, by implementing a <code>compose</code> method :</p>

<pre class="prettyprint">scala&gt; def compose[A,B,C](f: A =&gt; Option[B], g: B =&gt; Option[C]) : A =&gt; Option[C] = a =&gt; f(a).flatMap(g)
compose: [A, B, C](f: A =&gt; Option[B], g: B =&gt; Option[C])A =&gt; Option[C]

scala&gt; compose(f,g)(3)
res1: Option[Int] = Some(8)
</pre>

<p>But it seems like reinventing the wheel, and it will only work for <code>Option</code>, and not for all <code>Monad</code>s.</p>

<h3>
<a name="user-content-to-go-further" class="anchor" href="#to-go-further" aria-hidden="true"><span class="octicon octicon-link"></span></a>To go further</h3>

<p>Here is some features that are not used but could be useful.</p>

<ul class="task-list">
<li>tagged type to add type safety on <code>Id</code> (compositeIds could return <code>List[Id @@ Composite]</code>
</li>
<li>use 'Reader' monad to manage store dependency</li>
</ul><h3>
<a name="user-content-links" class="anchor" href="#links" aria-hidden="true"><span class="octicon octicon-link"></span></a>Links</h3>

<ul class="task-list">
<li><a href="http://eed3si9n.com/learning-scalaz/">Learning scalaz</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example">Scalaz examples</a></li>
</ul>
