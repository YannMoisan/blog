---
title: Solve type erasure
description: How to solve type erasure issue in Scala
layout: blog
---
<p>A common pitfall with JVM languages is type erasure. Let's see an example :</p>

<pre class="prettyprint">
List(1).isInstanceOf[List[String]]
</pre>

<p>Hopefully, it's not a problem with Scala. Prior to version 2.10, Scala uses Manifest</p>

<pre class="prettyprint">
def foo[T](x: List[T])(implicit m: Manifest[T]) = {
  if (m &lt;:&lt; manifest[String])
    println("Hey, this list is full of strings")
  else
    println("Non-stringy list")
}
</pre>

<p>But Scala 2.10 comes with a new reflection API</p>

<pre class="prettyprint">
import scala.reflect.runtime.universe._
def foo[T:TypeTag](x: List[T]) = {
  val t = typeOf[T]
  if (t &lt;:&lt; typeOf[String])
    println("Hey, this list is full of strings")
  else
    println("Non-stringy list")
}
</pre>

<p>On contrary to Manifest, TypeTag handles correctly path dependent type, existential types, â€¦ So if you are using
Scala 2.10 and Manifest, consider to migrate.</p>
