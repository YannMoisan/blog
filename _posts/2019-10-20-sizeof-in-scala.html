---
title: Sizeof in Scala
description: Size of in Scala
layout: blog
---
<p>
This blog post will show the impact of different ways to store a couple of integers in Scala on the memory footprint of a program.
</p>

<h2>Reminder on the JVM</h2>

<p>
Every object on the JVM has a header. It consists of a mark word and a klass pointer.
On 64 bit architectures with a heap < 32G (i.e. with compressed oops), the header has a size of 12 bytes.
</p>

<p>
Java objects are 8-byte aligned by default. This can be changed with a JVM flag.
</p>

<pre class="prettyprint"><code>
java -XX:+PrintFlagsFinal -version | grep ObjectAlignmentInBytes
     intx ObjectAlignmentInBytes                    = 8                                   {lp64_product}
</code></pre>

<p>
So, the minimum object size is 16 bytes for modern 64-bit JDK since the object has 12-byte header, padded to a multiple of 8 bytes.
</p>

<p>
The size of an object is the object header + the size of its fields + the overhead of alignment
</p>

<p>
A primitive int takes 4 bytes
</p>

<p>
A java.lang.Integer takes 16 bytes : 12 bytes for the header and 4 bytes for the field (yes, this is a huge overhead)
</p>

<h2>Tools</h2>

<p>
Apache Spark, a tool for large-scale data processing, has a class to measure the size of an object : SizeEstimator.estimate
</p>

<p>
I use ammonite, a better Scala REPL that allow to dynamically load dependencies
</p>

<p>
Let's check the size of an Integer
</p>

<pre class="prettyprint"><code>
@ import $ivy.`org.apache.spark::spark-sql:2.4.0`
import $ivy.$

@ import org.apache.spark.util.SizeEstimator._
import org.apache.spark.util.SizeEstimator._

@ estimate(new Integer(1))
res2: Long = 16L
</code></pre>

So far, so good !

<h2>Comparing different ways to store 2 ints</h2>

<p>
Let's create a simple Wrapper to store 2 ints
</p>

<pre class="prettyprint"><code>
case class IntInt(i: Int, j: Int)
</code></pre>

<p>
The size is
</p>
<ul>
    <li>object header : 12 bytes</li>
    <li>2 int fields : 2 * 4 = 8 bytes</li>
    <li>total = 20 bytes, so 24 bytes with alignment</li>
</ul>

<p>
But it will be awkward to create classes for all combinaison of types, so let's create a generic pair object.
</p>

<pre class="prettyprint"><code>
@ class Pair[A, B](val a: A, val b: B)
defined class Pair

@ estimate(new Pair(1, 2))
res4: Long = 56L
</code></pre>

<p>
On the JVM, generics and primitive types don't play well together. Here
primitive types passed to the constructor need to be boxed to java.lang.Integer
objects.
</p>

<p>
Let's check the number by hand. The size is
</p>
<ul>
    <li>object header : 12 bytes</li>
    <li>2 reference fields : 2 * 4 = 8 bytes</li>
    <li>2 Integers : 2 * 16 = 32 bytes</li>
    <li>total = 52 bytes, so 56 bytes with alignment</li>
</ul>

<p>
In order to reduce the overhead due to boxing, Scala has a feature called specialized.
</p>

<p>
In this case, the compiler will generate specialized classes for each
combination of specialized argument types.
</p>

<pre class="prettyprint"><code>
@ case class SpPair[@specialized(Int) A, @specialized(Int) B](a: A, b: B)
defined class SpPair

@ estimate(SpPair(1, 2))
res7: Long = 32L
</code></pre>

<p>
Surprisingly, because the specialization is supposed to solve the overhead
issue, there is still a difference with the simple wrapper.
</p>

<p>
Let's dig into that
</p>

<pre class="prettyprint"><code>
@ SpPair(1, 2).getClass
res8: Class[?0] = class ammonite.$sess.cmd6$SpPair$mcII$sp
</code></pre>

<p>
The class name is SpPair$mcII$sp and not SpPair. it's the class generated by
the compiler.
</p>

<pre class="prettyprint"><code>
@ SpPair(1, 2).getClass.getDeclaredFields.map(_.getType)
res9: Array[Class[?0] forSome { type ?0 }] = Array(int, int)
</code></pre>

<p>
And this class has 2 fields of type int. So the size should be the same as that
of the simple wrapper.
</p>

<p>
Let's see if there is a superclass …
</p>

<pre class="prettyprint"><code>
@ SpPair(1, 2).getClass.getSuperclass
res10: Class[?0] = class ammonite.$sess.cmd6$SpPair
</code></pre>

<p>
There is a superclass, it's SpPair.
Let's have a look to the fields of the superclass
</p>

<pre class="prettyprint"><code>
@ SpPair(1, 2).getClass.getSuperclass.getDeclaredFields.map(_.getType)
res11: Array[Class[?0] forSome { type ?0 }] = Array(class java.lang.Object, class java.lang.Object)
</code></pre>

<p>
Unfortunately, the superclass has 2 fields of type Object, that will always be
null for a specialized instance. Nevertheless, a reference field with a null
value on the JVM take the
same space than a non-null reference.
</p>

<p>
so the size is
</p>
<ul>
    <li>object header : 12 bytes</li>
    <li>2 reference fields : 2 * 4 = 8 bytes</li>
    <li>2 ints : 2 * 4 = 8 bytes</li>
    <li>total = 28 bytes, so 32 bytes with alignment. (Q.E.D.)</li>
</ul>

<p>
We can double check with jol, another interesting tool when it comes to
understand memory consumption. Our SpPair class use exactly the same mechanism as the
Tuple2 class from the scala standard library. So here is the result of jol on
scala.Tuple2$mcII$sp, the specialized instance for pair of ints.
</p>

<pre class="prettyprint"><code>
java -jar jol-cli-0.9-full.jar internals -cp /usr/local/Cellar/scala/2.13.1/libexec/lib/scala-library.jar 'scala.Tuple2$mcII$sp'                                                   

Instantiated the sample instance via public scala.Tuple2$mcII$sp(int,int)

scala.Tuple2$mcII$sp object internals:
 OFFSET  SIZE               TYPE DESCRIPTION                               VALUE
      0     4                    (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4                    (object header)                           85 0a 02 f8 (10000101 00001010 00000010 11111000) (-134083963)
     12     4   java.lang.Object Tuple2._1                                 null
     16     4   java.lang.Object Tuple2._2                                 null
     20     4                int Tuple2$mcII$sp._1$mcI$sp                  0
     24     4                int Tuple2$mcII$sp._2$mcI$sp                  0
     28     4                    (loss due to the next object alignment)
Instance size: 32 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
</code></pre>

<p>
Hopefully, the instance size computed by jol is also 32 bytes. 
It shows java.lang.Object fields (_1 and _2) from the superclass and int fields from the subclass (_1$mcI$sp, _2$mcI$sp)
</p>

<p>
Let's see a last solution with an array.
</p>

<pre class="prettyprint"><code>
@ SizeEstimator.estimate(Array(1,2))
res15: Long = 24L
</code></pre>

<p>
The size is
</p>
<ul>
    <li>object header : 12 bytes</li>
    <li>length fields : 4 byte</li>
    <li>2 ints : 2 * 4 = 8 bytes</li>
    <li>total = 24 bytes</li>
</ul>

<h2>Conclusion</h2>
<table>
    <tr>
        <td>Structure</td>
        <td>Size</td>
    </tr>
    <tr>
        <td>Simple Wrapper</td>
        <td>24</td>
    </tr>
    <tr>
        <td>Generic Pair</td>
        <td>56</td>
    </tr>
    <tr>
        <td>Specialized Pair</td>
        <td>32</td>
    </tr>
    <tr>
        <td>Array</td>
        <td>24</td>
    </tr>
</table>

<p>If you instantiate a lot of objects, it's worth knowing the tradeoffs of each solution.</p>

<h2>Links to go further</h2>
<ul>
    <li><a href="https://scalac.io/specialized-generics-object-instantiation/">specialized generics on scalac blog</a></li>
    <li><a href="https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/">compressed references</a></li>
    <li><a href="https://shipilev.net/jvm/anatomy-quarks/24-object-alignment/">object alignment</a></li>
    <li><a href="https://openjdk.java.net/projects/code-tools/jol/">jol</a></li>
    <li><a href="https://www.javaworld.com/article/2077408/sizeof-for-java.html">sizeof for Java</a></li>
</ul>
