---
title: Tuples
description: Tuples
layout: blog
---
<p>La librairie Scala n'offre pas de méthodes utilitaires sur des collections de tuples. Nous allons voir comment
implémenter un flatMap sur toutes les valeurs. Nous allons partir de l'implémentation la plus simple qui vient
à l'esprit pour l'améliorer progressivement.</p>
<pre class="prettyprint">
def flatMapValues[A, B, C](s:Seq[(A, B)])(f: B =&gt; Seq[C]) : Seq[(A, C)] = 
  s.flatMap { case (a, b) =&gt; f(b).map((a, _)) }
</pre>
<p>Le code client est alors <code>flatMapValues(Seq("a"-&gt;1, "b"-&gt;2))(Seq.fill(_)("x"))</code>. Afin d'avoir un
code client <i>fluent</i>, on peut introduire une <a
href="http://docs.scala-lang.org/sips/completed/implicit-classes.html"><i>implicit class</i></a>, qui permet
de fournir des méthodes d'extension à un type existant, une séquence de tuples ici.
<pre class="prettyprint">
implicit class TuplesOps[A, B](s: Seq[(A, B)]) {
  def flatMapValues[C](f: B =&gt; Seq[C]): Seq[(A, C)] =
    s.flatMap { case (a, b) =&gt; f(b).map((a, _))}
}
</pre>
<p>Le code client devient <code>Seq("a"-&gt;1, "b"-&gt;2).flatMapValues(Seq.fill(_)("x"))</code>. Malheureusement, un
surcoût se produit à l'execution dû à l'instanciation de <code>TuplesOps</code>, c'est le <i>wrapping</i>. Or, cela peut être éviter en utilisant une <a
    href="http://docs.scala-lang.org/overviews/core/value-classes.html"><i>value class</i></a> : </p>
<pre class="prettyprint">
implicit class TuplesOps[A, B](val s: Seq[(A, B)]) extends AnyVal {
  def flatMapValues[C](f: B =&gt; Seq[C]): Seq[(A, C)] =
    s.flatMap { case (a, b) =&gt; f(b).map((a, _))}
}
</pre>
<p>Le problème est que ce code n'est pas assez générique. On ne peut pas appeler la méthode avec un <code>Set</code> par
exemple. Il va donc falloir utiliser une interface commune : <code>Traversable</code>, qui définit les fonctions
<code>map</code>, <code>flatMap</code>.</p>
<pre class="prettyprint">
implicit class TuplesOps[A, B](val s: Traversable[(A, B)]) extends AnyVal {
  def flatMapValues[C](f: B =&gt; Traversable[C]): Traversable[(A, C)] =
    s.flatMap { case (a, b) =&gt; f(b).map((a, _))}
}
</pre>
<p>Le problème est que peu importe le type de la collection, le retour sera toujours un <code>Traversable</code>, nous
forçant à une transformation explicite. Cependant, nous pouvons encore faire mieux en reproduisant le principe 
    <i>same-result-type</i> mis en oeuvre dans les collections Scala grâce au trait <a
    href="http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html#outline-of-class-traversablelike">TraversableLike</a>.</p>
<pre class="prettyprint">
implicit class TuplesOps[A, B, Repr <: Traversable[(A, B)]](val s: TraversableLike[(A, B), Repr]) extends AnyVal {
  def flatMapValues[C, That](f: B => TraversableOnce[C])(implicit bf: CanBuildFrom[Repr, (A, C), That]) =
    s.flatMap { case (a, b) => f(b).map((a, _))}
}
</pre>
<p>L'écriture de code générique, élégant pour l'appelant, et performant
requiert quelques efforts en Scala…</p>
